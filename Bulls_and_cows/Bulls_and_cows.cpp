#include <iostream>
#include <time.h>
#include <cstdlib>
#define size 4				// именование литерала
/* Есть библиотеки с окончанием ".h" и начинающиеся на "с..." (time.h и ctime,...). ".h" пришли из "C", а "с..." были добавлены для С++ с уже встроенными в них "С" биб-
лиотеками. Если зайти внутрь библиотеки С++, в ней будет подключена соответствующая ей библиотека из языка С. */
using namespace std;

/* 3578
   1768 => 1 бык и 1 корова
Если одна и таже цифра друг под другом, например 8, то это 1 бык, а если в обоих числах присутствует одна и тажк цифра, но в разных позициях в числе, то это корова. По
количеству быков и коров в веденном числе пользователь должен угадать загаданное число. Сравнение идет по каждой цифре числа. 4 быка скажут что число угадано.

   Требования:
1. Число должно быть четырехзначным. Ноль в начале в счет не идет и не вводится в игру (0137 число трехзначное)
2. Одинаковых цифр быть не должно (7732 вводить нельзя)

		Техническое задание:
   Пользовательский интерфейс (меню)
   Проверка ввода	-	do_while
   Хранение чисел	-	массивы
F1 Загадывание числа
F2 Разделение числа на цифры
F3 Сравнение чисел
F3 Результат сравнения
   Результат игры
   Учет попыток
   Цикл повторной игры
   Псевдографика

Сравниваться числа будут по цифрам, а след. храниться числа будем в массиве уже разделенном на отдельные цифры. Сравниваться будут два глоб.массива поэлементно. Глоб.
массив в функцию передавать не нужно. Пусть размер массива тоже будет глоб.константой, чтобы его тоже не надо было передавать в функции.
(!) когда узнаем как можно создавать массивы переменной длины, можно будет выбирать длину числа.
Пользовательское число необходимо нарезать, а загаданное число будет создаваться в массив.
Нам потребуется глоб.константа. Чтобы не тратить на нее время сделаем ее через define size. Создам глоб.массив хранящий загаданное число. Глоб.объекты по умолчанию пус-
тые. */
int number[size];
int value[size];					// глоб.массив, хранящий введенное игроком число
/* Функцию загадывания числа. Т.к. массив возможно изменять в функции, то и не нужно ничего возвращать. Число будет сразу в массив помещаться, в каждую ячейку каждая
циферка. Передавать в функцию ничего не нужно т.к. массив number глобальный, а size это define (там где будет size, само подставится четверкой) */
void SetNumber();
/* Функцию преобразования (нарезки) числа, введенного игроком в массив цифр. Т.к. она будет преобразовывать число, введенное пользователем в массив цифр. Массив value
глобальный.
(!) не надо все делать в самой функции, лучше ввод значений создать отдельно, и работу со значениями тоже отдельно, чтобы в одну функцию все в кучу не смешивать, за
исключением если в функции нужно вводить число с клавиатуры. */
void Slice(int);
/* Функция сравнения и определения результата. Функция будет возвращать быков и коров. return может вернуть только одно значение (два нельзя), но для программы важны
лишь быки, по которым ей будет ясно победил игрок или нет. Если количество быков совпадает с количеством цифр в числе, то игрок победил. Для пользователя быки и коровы
просто выведутся на экран. Вернет функция количество быков. */
int Result();

int main()
{
	system("chcp 1251");
	system("cls");
	srand(time(NULL));
	cout << "-------------------------------------------------------Игра Быки и Коровы!----------------------------------------------------------------------\n" << endl;
	int win = 0, digit = 0;
	SetNumber();
	/*
	for (int i = 0; i < size; i++)													// тестовый вывод загаданного числа на экран
	{
		cout << number[i];
	}
	cout << endl;
	*/
	do																				// цикл игры до победы
	{
		/* Проверка пользовательского ввода:
		1.вариант: если нужно ограничиться 4-х значным числом, то можно прописать условие Digit < 1000 || Digit >= 10000. Это значит что число не четырехзначное. А
		если не 4 знака, а 5 или 6, то этот вариант не подойдет.
		2.вариант: чтобы проверить size-значное число нужно проанализировать логику и найти закономерность:
		двухзначное число:		10   <= digit < 100			10^1 <= digit < 10^2
		трехзначное число:		100  <= digit < 1000		10^2 <= digit < 10^3
		четырехзначное число:	1000 <= digit < 10000		10^3 <= digit < 10^4, т.о.
		size-значное число получается от
											10^size-1 <= digit < 10^size */
		do
		{
			cout << "Введите " << size << "-значное число, состоящее из разных цифр: ";
			cin >> digit;

			if (digit < pow(10, size - 1) || digit >= pow(10, size))				// если пользователь ввел нечетырехзначное число:
				cout << "Некорректный ввод! Проверьте количество знаков в числе. Число не должно начинаться с нуля." << endl;
		} while (digit < pow(10, size - 1) || digit >= pow(10, size));
		/* Если digit меньше чем 1000 или больше/равен 10000 при size == 4. Если это условие выполняется, то неверный ввод
		Как только пользователь ввел правильное число, нарежем его: */
		Slice(digit);
		win = Result();																// считаем количество быков и коров и помещаем количество быков в переменную win 

	} while (win != size);															// играем пока количество быков не равно количеству цифр в загаданном числе
	/* Если мы вышли из цикла do_while это значит что игрок угадал, а именно то число, которое он вводил совпало с загаданным. Игрок вводит digit. Победа игрока будет
	когда digit совпадет с тем что в number хранится. Игрок вводит число, помещаемое в digit. Далее его функция режет, сравнивает, и если количество быков совпало, то
	победа. */
	cout << "Вы угадали! Загаданное число: " << digit << endl;						// когда игрок угадал, его digit совпадает с заг.числом, его и выведем для простоты
	system("pause");
}
/* Т.к. надо заг.число помещать в массив, то нужно каждую цифру загадывать по-отдельности [][][][]. Т.к. первая цифра не должна быть нулем, ее можно загадать от-
дельно. А генерация каждой последующей цифры не отличается от предыдущей, след, внесем ее в цикл for. Там может быть и ноль, и не ноль. После того как была сгенериро-
вана след.цифра, необходимо проверить не совпала ли она с предыдущими, пройти в цикле и проверить предыдущие цифры (заново пройтись по всему массиву). */
void SetNumber()
{
	number[0] = rand() % 9 + 1;														// числа от 1 до 9 включительно
	for (int i = 1; i < size; i++)													// генерация оставшихся цифр в числе
	{
		number[i] = rand() % 10;
		for (int j = 0; j < i; j++)													// проверка всех цифер перед j.
		{
			if (number[i] == number[j])												// новая цифра совпала с одной из предыдущих
			{
				i--;																// нужно i-ю цифру заново сгенерировать и вернуться к циклу генерации
				break;																// операторы break и continue сработают на ближ.цикл, в котором они были объявлены
			}
		}
	}
}
/* continue пропускает все действия, указанные после него и компилятор переходит к проверке условия и увеличению счетчика, а break прерывает полностью цикл. continue
пропускает какой-то шаг цикла (3-й, 5-й,...), т.е. пропуск одной итерации цикла, а break полностью остановит весь цикл и выйдет из него.

Функция нарезки числа. Принимать она будет в качестве параметра число, которое будет порезано. Чтобы взять отдельную цифру из числа есть два варианта:
1. Если известно точное количество цифр в числе. Например их 4 (3578). Делю на 1000 и получаю первою цифру 3. Далее беру остаток от деления 3578 на 1000 и получаю 578.
   А после 578 делю на 100 и получаю 5. Далее беру остаток от деления 578 на 100 и получаю 78. Потом делю 78 на 10 и получаю 7, беру остаток от деления 78 на 10 и полу-
   чаю 8. Это алгоритм деления на 10 в степени размер-1, где размер постоянно уменьшается.
   Этот способ неудобен для цикла и лучше с малым числом. Приведем в степени: 1000 это 10^3, где 3 это size-1 (если 4-х значное число). Далее будет цикл for:
   for (int i = size; i > 0; i--)
   {
		digit/pow(10,i-1);
   }
   Последняя восьмерка встает поперек горла и необходимо еще что-то для нее придумать и усложнить алгоритм.
2. Деление на 10 с отщипыванием последних цифр, а не первых. Но это и не важно ибо тут массив и есть возможность перевернуть последовательность цифр. Второй вариант
   проще. Если такой возможности нет, то придется обходиться 1-м вариантом. А в массив можно в любую ячейку любое значение поместить. Сложем в массив в обратном порядке
   начав не с нулевого элемента, а с третьего. Итак далее сам алгоритм:
		3578 % 10 = 8
		3578 / 10 = 357
		357 % 10 = 7
		357 / 10 = 35
		35 % 10 = 5
		35 / 10 = 3
		3 % 10 = 3
		3 / 10 = 0
	Все операции удобны и из них я буду выбирать лишь нужные цифры: 8; 7; 5; 3; В третий элемент положу 8, во второй 7..., в нулевой 3.
Нарезать можно с любого края, но чаще всего это удобнее делать с конца, но при этом придется разворачивать последовательность полученных цифр. С массивом это удобно. */

void Slice(int digit)												// функция будет применима к числу любой длины, но при этом нужно соответствующий размер массива
{
	for (int i = size - 1; i >= 0; i--)								// seze-1 т.к. нужен сразу 3-й индекс элемента (всего 4 элемента), а последний будет нулевой
	{
		value[i] = digit % 10;										// записываем цифру в массив
		digit /= 10;												// "отрезаем" записанную цифру от числа
	}
}

/* Функция поиска быков и коров, сравнивая цифры друг с другом. Тут нужно обратить внимание на механику сравнения. Пользовательский ввод непредсказуем и от него оттал-
киваться тяжело и неверно ибо в пользовательском вводе числа могут повторяться, поэтому нужно из загаданного числа брать цифры и искать их в пользовательском. При взя-
тии цифры из загаданного числа первым делом проверится бык (бык имеет приоритет), а если бык не встречен, то проверяется корова. Если бык найден, то переступаем к сле-
дующей цифре загаданного числа. Если бык не встречен, а попалась корова, то также переходим к следующей цифре загаданного числа. Одна цифра не может быть одновременно
и быком, и коровой, только что-то одно. Брать в расчет одинаковые в пользовательском ряду цифры не имеет смысла, т.к. от этого цифра не изменится и ее количество в за-
гаданном числе не увеличится. */

int Result()
{
	int bulls = 0, cows = 0;
	for (int i = 0; i < size; i++)			// цикл прохода по загаданному числу
	{
		if (number[i] == value[i])			// если цифра из заг.числа стоит в таком же разряде как и у введенном игроком числа (если текущая цифра из заг.числа бык)
		{
			bulls++;
			continue;						// переходим к след.цифре в заг.числе
		}
		for (int j = 0; j < size; j++)		// цикл поиска коровы - цифры из заг.числа, введенного игроком (с каждой цифрой от начала числа)
		{
			if (number[i] == value[j])		// если текущая цифра из заг.числа где-то есть в числе игрока
			{
				cows++;
				break;						// если корова найдена, то больше корову искать не надо (выходим из цикла поиска коровы и переходим к след.цифре заг.числа)
			}
		}
	}
	cout << "Быки: " << bulls << " Коровы: " << cows << endl;
	return bulls;
}						// ДЗ 2.34 и 2.51